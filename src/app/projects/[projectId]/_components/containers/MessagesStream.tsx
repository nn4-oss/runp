"use client";

import React from "react";

import { useTRPC } from "@/trpc/client";
import { useSuspenseQuery } from "@tanstack/react-query";

import AssistantBubble from "../data/AssistantBubble";
import UserBubble from "../data/UserBubble";
import LoadingBubble from "../data/LoadingBubble";

import { MessageRole, type Fragment } from "generated/prisma";

type MessagesStreamProps = {
  projectId: string;
  activeFragment: Fragment | null;
  setActiveFragment: (fragment: Fragment | null) => void;
};

function MessagesStream({
  projectId,
  activeFragment,
  setActiveFragment,
}: MessagesStreamProps) {
  const [enableRefetch, setEnableRefetch] = React.useState(true);

  const streamEndRef = React.useRef<HTMLDivElement>(null);
  const lastAssistantMsgRef = React.useRef<string | null>(null);

  const trpc = useTRPC();
  const { data: messages } = useSuspenseQuery(
    trpc.messages.getMany.queryOptions(
      { projectId },
      {
        refetchInterval: enableRefetch ? 1000 : false,
        refetchOnWindowFocus: true,
      },
    ),
  );

  /** Show loading state if Last saved message was not sent by user  */
  const lastMessage = messages.at(-1);
  const isLastUserMessage = lastMessage?.role === "USER";

  // Safe fallback for findLast to avoid older-browser regressions.
  const predicate = (m: (typeof messages)[number]) =>
    m.role === MessageRole.ASSISTANT;

  const lastAssistantMessage =
    (messages as any).findLast?.(predicate) ??
    [...messages].reverse().find(predicate);

  /** Reset Auto-Fetch is lastMessage is from assistant */
  React.useEffect(() => {
    if (lastMessage?.role === "USER") setEnableRefetch(true);
    if (lastMessage?.role === "ASSISTANT") setEnableRefetch(false);
  }, [messages.length]);

  /** Auto-scroll to bottom when messages change */
  React.useEffect(() => {
    streamEndRef.current?.scrollIntoView({ behavior: "smooth" });
  }, [messages.length]);

  /** Auto-select/scroll the last fragment generated by the code agent */
  React.useEffect(() => {
    if (
      lastAssistantMessage?.fragment &&
      lastAssistantMessage.id !== lastAssistantMsgRef.current
    ) {
      setActiveFragment(lastAssistantMessage.fragment);
      lastAssistantMsgRef.current = lastAssistantMessage.id;
    }
  }, [
    messages,
    activeFragment?.id,
    lastAssistantMessage?.fragment,
    lastAssistantMessage?.id,
    setActiveFragment,
  ]);

  return (
    <div className="grid g-large-10 p-t-large-10">
      {messages.map((message) => (
        <React.Fragment key={message.id}>
          {message.role === MessageRole.USER && (
            <UserBubble content={message.content} />
          )}
          {message.role === MessageRole.ASSISTANT && (
            <AssistantBubble
              type={message.type}
              content={message.content}
              fragment={message.fragment}
              createdAt={message.createdAt}
              isActiveFragment={activeFragment?.id === message.fragment?.id}
              onFragmentClick={() => setActiveFragment(message.fragment)}
            />
          )}
        </React.Fragment>
      ))}

      {isLastUserMessage && <LoadingBubble />}

      <div ref={streamEndRef} />
    </div>
  );
}

export default MessagesStream;
