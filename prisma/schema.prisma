generator client {
  provider = "prisma-client-js"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum ScopeEnum {
  FREE
  PRO
  ENTERPRISE
}

enum MessageRole {
  USER
  ASSISTANT
}

enum MessageType {
  RESULT
  ERROR
}

enum ThirdPartyServiceType {
  OPENAI
  E2B
}

// Represents an application user, with identity managed by Clerk.
// We store references to Clerkâ€™s userId and related metadata, along with
// application-specific fields such as scope, projects, and integrations.
// - `idx_user_scope`: Optimizes queries by user scope.
// - `idx_user_scopeKey`: Optimizes lookups by scopeKey.
model User {
  id        String    @id // Clerk userId

  scope     ScopeEnum    @default(FREE)
  scopeKey  String   // Opaque secret reference (env keys)

  email    String?
  name     String?
  imageUrl String?

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  @@index([scope], name: "idx_user_scope")
  @@index([scopeKey], name: "idx_user_scopeKey")
}

// Projects belong to a user (via Clerk userId) and contain messages.
// We index userId for fast lookups like "all projects for a user".
model Project {
  id        String    @id @default(uuid())
  name      String
  userId    String    @db.VarChar(255) // Clerk userId
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  messages  Message[]

  @@index([userId], name: "idx_project_userId")
}


// Messages belong to a project. Cascade delete ensures that when a project
// is deleted, its messages are also removed.
model Message {
  id        String      @id @default(uuid())
  content   String
  role      MessageRole
  type      MessageType
  createdAt DateTime    @default(now())
  updatedAt DateTime    @updatedAt

  fragment  Fragment?
  projectId String
  project   Project     @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@index([projectId], name: "idx_message_projectId")
}


// Each message can have at most one fragment (1:1 relation).
// Cascade delete ensures fragments are removed with their message.
model Fragment {
  id        String   @id @default(uuid())
  messageId String   @unique
  message   Message  @relation(fields: [messageId], references: [id], onDelete: Cascade)

  sandboxUrl String
  title      String
  files      Json

  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
}


// Credentials belong to a user (via Clerk userId).
// We enforce uniqueness on (userId, name) so a user cannot have two
// credentials with the same name.
// Indexed userId for fast lookups.
model Credential {
  id        String    @id @default(uuid())
  userId    String    @db.VarChar(255)
  name      String
  value     String
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  integrations Integration[]

  @@unique([userId, name], name: "userId_name")
  @@index([userId], name: "idx_credential_userId")
}

// Join table linking a user + service (enum) + credential.
// Allows marking one credential as "primary" per service per user.
// Indexed heavily for performance on common queries.
model Integration {
  id           String     @id @default(uuid())
  service      ThirdPartyServiceType
  credentialId String
  userId       String     @db.VarChar(255)
  isPrimary    Boolean    @default(false)

  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt

  credential   Credential @relation(fields: [credentialId], references: [id], onDelete: Cascade)

  @@index([userId], name: "idx_integration_userId")
  @@index([service], name: "idx_integration_service")
  @@index([credentialId], name: "idx_integration_credentialId")
}

// Rate limiting per user's projects/messages.
model Usage {
  key String     @id @default(uuid())
  points Int
  expire DateTime?
}